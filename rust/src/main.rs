// src/main.rs
// Generated by Claude 4, Fixed by Gemini 2.5 Pro
use clap::Parser;
use futures::stream::{self, StreamExt};
use indicatif::{MultiProgress, ProgressBar, ProgressStyle};
use reqwest::Client;
use std::path::Path;
use std::sync::Arc;
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};
use tokio::fs::File as TokioFile;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader as TokioBufReader};
use tokio::sync::Semaphore;
use url::Url as UrlCrate;

const MAX_FILENAME_DISPLAY_LENGTH: usize = 20;
const PROGRESS_BAR_WIDTH: usize = 25;
const SPEED_UPDATE_INTERVAL: Duration = Duration::from_millis(750);

#[derive(Parser)]
#[command(name = "DL")]
#[command(about = "A concurrent file downloader")]
struct Args {
    /// Number of concurrent downloads
    #[arg(short, long, default_value = "3")]
    concurrency: usize,

    /// File containing URLs to download
    urls_file: String,
}

struct SpeedTracker {
    last_update: Instant,
    last_bytes: u64,
    current_speed: f64,
}

impl SpeedTracker {
    fn new() -> Self {
        Self {
            last_update: Instant::now(),
            last_bytes: 0,
            current_speed: 0.0,
        }
    }

    fn update(&mut self, current_bytes: u64) {
        let now = Instant::now();
        let elapsed = now.duration_since(self.last_update);

        if elapsed >= SPEED_UPDATE_INTERVAL || self.current_speed == 0.0 && current_bytes > 0 {
            let bytes_diff = current_bytes.saturating_sub(self.last_bytes);
            if elapsed.as_secs_f64() > 0.0 {
                self.current_speed = bytes_diff as f64 / elapsed.as_secs_f64();
            } else if bytes_diff > 0 {
                self.current_speed = f64::INFINITY;
            }
            self.last_update = now;
            self.last_bytes = current_bytes;
        }
    }

    fn get_speed(&self) -> f64 {
        self.current_speed
    }
}

fn format_speed(bytes_per_second: f64) -> String {
    if bytes_per_second < 0.0 || bytes_per_second.is_nan() {
        return "--- B/s".to_string();
    }
    if bytes_per_second.is_infinite() {
        return "--- B/s".to_string();
    }
    if bytes_per_second < 1024.0 {
        return format!("{:6.2} B/s", bytes_per_second);
    }
    let kbps = bytes_per_second / 1024.0;
    if kbps < 1024.0 {
        return format!("{:6.2} KB/s", kbps);
    }
    let mbps = kbps / 1024.0;
    format!("{:6.2} MB/s", mbps)
}

// Note: This custom calculate_eta is sound, but indicatif's {{eta}} will be used.
// This function would be useful if you wanted a different ETA format or logic than indicatif provides.
fn _calculate_eta(speed_bps: f64, total_size: u64, current_size: u64) -> String {
    if speed_bps <= 0.0 || total_size == 0 || current_size >= total_size || speed_bps.is_infinite() || speed_bps.is_nan() {
        return "N/A".to_string();
    }

    let remaining_bytes = total_size.saturating_sub(current_size);
    if remaining_bytes == 0 {
        return "0s".to_string();
    }
    let remaining_seconds = remaining_bytes as f64 / speed_bps;

    if remaining_seconds < 60.0 {
        format!("{:.0}s", remaining_seconds)
    } else if remaining_seconds < 3600.0 {
        let minutes = remaining_seconds / 60.0;
        let seconds = remaining_seconds % 60.0;
        format!("{:.0}m{:.0}s", minutes, seconds)
    } else {
        let hours = remaining_seconds / 3600.0;
        let minutes = (remaining_seconds % 3600.0) / 60.0;
        let seconds = remaining_seconds % 60.0;
        format!("{:.0}h{:.0}m{:.0}s", hours, minutes, seconds)
    }
}

fn truncate_filename(filename: &str) -> String {
    if filename.len() > MAX_FILENAME_DISPLAY_LENGTH {
        format!("...{}", &filename[filename.len() - MAX_FILENAME_DISPLAY_LENGTH + 3..])
    } else {
        filename.to_string()
    }
}

async fn download_file(
    url_str: String,
    download_dir: &Path,
    client: &Client,
    multi_progress: &MultiProgress,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // ... (filename extraction logic as before) ...
    let mut filename = match UrlCrate::parse(&url_str) {
        Ok(parsed_url) => parsed_url
            .path_segments()
            .and_then(|segments| segments.last())
            .map(|s| s.to_string())
            .filter(|s| !s.is_empty() && s != "." && s != "/")
            .unwrap_or_else(|| {
                let ts = SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_millis();
                format!("download_{:x}.file", ts)
            }),
        Err(_) => {
            url_str
                .split('/')
                .last()
                .map(|s| s.to_string())
                .filter(|s| !s.is_empty() && s != "." && s != "/")
                .unwrap_or_else(|| {
                    let ts = SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_millis();
                    format!("download_{:x}.file", ts)
                })
        }
    };
    if let Some(pos) = filename.find('?') { filename = filename[..pos].to_string(); }
    if filename.is_empty() {
        let ts = SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_millis();
        filename = format!("download_{:x}.file", ts);
    }

    let file_path = download_dir.join(&filename);
    let display_name = truncate_filename(&filename);

    // Define styles
    let bar_style_template_str = format!(
        "{:<width$}: [{{bar:{bar_width}}}] {{percent:>6.2}}% ({{bytes:>8}} / {{total_bytes:>8}}) @ {{msg}} ETA: {{eta}}",
        display_name,
        bar_width = PROGRESS_BAR_WIDTH,
        width = MAX_FILENAME_DISPLAY_LENGTH
    );
    let bar_style = ProgressStyle::default_bar()
        .template(&bar_style_template_str)?
        .progress_chars("=>-");

    let spinner_style_template_str = format!(
        "{:<width$}: [{{spinner}}] ({{bytes:>8}} / ??) @ {{msg}} ETA: {{eta}}", // Use ?? for unknown total
        display_name,
        width = MAX_FILENAME_DISPLAY_LENGTH
    );
    let spinner_style = ProgressStyle::default_spinner()
        .template(&spinner_style_template_str)?;


    // Try to get file size with HEAD request
    let head_size_opt = client.head(&url_str).send().await
        .ok()
        .and_then(|resp| if resp.status().is_success() { resp.content_length() } else { None });

    let pb: ProgressBar;
    let mut current_known_total_size: u64 = 0; // 0 means unknown or genuinely zero
    let mut is_currently_spinner: bool;

    if let Some(size) = head_size_opt {
        if size > 0 {
            pb = multi_progress.add(ProgressBar::new(size));
            pb.set_style(bar_style.clone());
            current_known_total_size = size;
            is_currently_spinner = false;
        } else { // size == 0 from HEAD
            pb = multi_progress.add(ProgressBar::new_spinner());
            pb.set_style(spinner_style.clone());
            // current_known_total_size remains 0
            is_currently_spinner = true;
        }
    } else { // No size from HEAD
        pb = multi_progress.add(ProgressBar::new_spinner());
        pb.set_style(spinner_style.clone());
        // current_known_total_size remains 0
        is_currently_spinner = true;
    }

    pb.set_message("0.00 B/s"); // Initial message

    // Start download
    let response = client.get(&url_str).send().await?;

    if !response.status().is_success() {
        let err_msg = format!("Error: {}", response.status());
        pb.finish_with_message(err_msg.clone());
        return Err(err_msg.into());
    }

    // Refine total size and style based on GET response, especially if we started with a spinner
    if is_currently_spinner {
        if let Some(size_from_get) = response.content_length() {
            if size_from_get > 0 {
                pb.set_length(size_from_get); // Important: Set length before style for bar
                pb.set_style(bar_style.clone());
                current_known_total_size = size_from_get;
                is_currently_spinner = false;
            } else { // size_from_get == 0
                pb.set_length(0); // Spinner with 0 length (will show 100% if switched to bar later, or N/A ETA)
                current_known_total_size = 0;
                // is_currently_spinner remains true
            }
        } else {
            // Size still unknown from GET. PB is spinner. current_known_total_size remains 0.
            // ETA will be '???'
        }
    } else { // Already a bar from HEAD (current_known_total_size > 0)
        // Optionally, could compare with response.content_length() and log discrepancies
        // For now, we trust the positive size from HEAD if we used it.
        if let Some(size_from_get) = response.content_length() {
            if size_from_get == 0 && current_known_total_size > 0 {
                 // HEAD said X bytes, GET says 0 bytes. This is a conflict.
                 // For simplicity, we'll stick with current_known_total_size from HEAD.
                 // A more robust solution might switch to a spinner here or error.
            } else if size_from_get > 0 && size_from_get != current_known_total_size {
                 // HEAD and GET report different positive sizes. Could update length:
                 // pb.set_length(size_from_get);
                 // current_known_total_size = size_from_get;
            }
        }
    }

    let mut file = TokioFile::create(&file_path).await?;
    let mut speed_tracker = SpeedTracker::new();
    let mut bytes_downloaded = 0u64;

    let mut stream = response.bytes_stream();
    while let Some(chunk_result) = stream.next().await {
        let chunk = chunk_result?;
        file.write_all(&chunk).await?;

        let chunk_len = chunk.len() as u64;
        bytes_downloaded += chunk_len;
        pb.set_position(bytes_downloaded);

        speed_tracker.update(bytes_downloaded);
        let speed_val = speed_tracker.get_speed();
        pb.set_message(format_speed(speed_val));
    }
    
    // Finalize progress bar state
    if is_currently_spinner {
        // If it was a spinner, means total size was unknown or 0 until the end.
        // Now, total size is `bytes_downloaded`. Switch to bar style for finish.
        pb.set_style(bar_style.clone()); // Set bar style first
        pb.set_length(bytes_downloaded);  // Then set length for the bar
        pb.set_position(bytes_downloaded);// And position
    } else {
        // Was already a bar. Ensure position is at the end of its known length.
        // current_known_total_size could be >0 or 0 if GET confirmed Content-Length: 0.
        pb.set_position(current_known_total_size);
        if current_known_total_size == 0 && bytes_downloaded > 0 {
            // This means HEAD reported >0, but GET reported 0 (or vice versa, and logic led here)
            // and we downloaded bytes anyway. Server is inconsistent.
            // Update length to what was actually downloaded.
            pb.set_length(bytes_downloaded);
            pb.set_position(bytes_downloaded);
        }
    }

    pb.finish_with_message("Done    ");
    Ok(())
}

// ... (read_urls_from_file and main functions remain the same) ...
async fn read_urls_from_file(file_path: &str) -> Result<Vec<String>, std::io::Error> {
    let file = TokioFile::open(file_path).await?;
    let reader = TokioBufReader::new(file);
    let mut lines = reader.lines();
    let mut urls = Vec::new();

    while let Some(line_result) = lines.next_line().await? {
        let url = line_result.trim();
        if !url.is_empty() {
            urls.push(url.to_string());
        }
    }

    Ok(urls)
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    let urls = read_urls_from_file(&args.urls_file)
        .await
        .map_err(|e| format!("Error reading URLs file '{}': {}", args.urls_file, e))?;

    if urls.is_empty() {
        println!("No URLs found in the file.");
        return Ok(());
    }

    let download_dir_path = Path::new("downloads");
    if !download_dir_path.exists() {
        tokio::fs::create_dir(download_dir_path)
            .await
            .map_err(|e| format!("Error creating download directory: {}", e))?;
    }

    println!(
        "Attempting to download {} files from '{}' into '{}' (concurrency: {})...",
        urls.len(),
        args.urls_file,
        download_dir_path.display(),
        args.concurrency
    );

    let client = Client::builder()
        .connect_timeout(Duration::from_secs(10))
        .build()?;

    let multi_progress = Arc::new(MultiProgress::new());
    let semaphore = Arc::new(Semaphore::new(args.concurrency));

    let download_tasks = stream::iter(urls)
        .map(|url| {
            let client_clone = client.clone();
            let download_dir_buf = download_dir_path.to_path_buf(); 
            let mp_clone = Arc::clone(&multi_progress);
            let sem_clone = Arc::clone(&semaphore);

            tokio::spawn(async move { 
                let _permit = sem_clone.acquire().await.unwrap(); 

                let result = download_file(
                    url.clone(),
                    &download_dir_buf,
                    &client_clone,
                    &mp_clone,
                )
                .await;

                if let Err(e) = &result {
                     // Error message is already on the progress bar itself for this download
                     // Optionally, log to stderr for a consolidated error view if desired:
                     // eprintln!("Download failed for {}: {}", url, e);
                }
                result 
            })
        })
        .buffer_unordered(args.concurrency); 

    let mut results = Vec::new();
    let mut tasks_stream = download_tasks; 
    while let Some(join_result) = tasks_stream.next().await {
        match join_result {
            Ok(download_result) => results.push(download_result),
            Err(join_error) => {
                eprintln!("A download task panicked: {}", join_error);
                results.push(Err(Box::new(join_error) as Box<dyn std::error::Error + Send + Sync>));
            }
        }
    }
    
    multi_progress.clear().ok(); // Clear all progress bars

    let successful = results.iter().filter(|r| r.is_ok()).count();
    let failed = results.len() - successful;

    println!("\nAll {} download tasks have been processed.", results.len());
    println!("Successful: {}, Failed: {}", successful, failed);

    Ok(())
}